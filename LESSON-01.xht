<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- FILE         : LESSON-01.xht
     LAST REVISED : 2016-01-12
     AUTHOR       : (C) Copyright 2016 by Peter C. Chapin
     SUBJECT      : Overview of C++. -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">

  <head>
    <title>Lesson #1</title>
    <meta name="Author" content="Peter C. Chapin" />
    <!-- <meta name="keywords" lang="en-US" content="..."> -->
    <meta name="ROBOTS" content="NOARCHIVE" />
    <link rel="stylesheet" href="cpp-tutorial.css" type="text/css" />
  </head>

  <body>
    <h1>Lesson #1</h1>
    <p class="subtitle">Overview of C++</p>

    <h2>Overview</h2>

    <p>In this lesson I will cover the following topics</p>

    <ol id="overview-list">
      <li><p>C++ as a better C.</p></li>
      <li><p>C++ as C++.</p></li>
      <li><p>Design goals of C++.</p></li>
      <li><p>Pros and cons of C++.</p></li>
    </ol>

    <h2>Body</h2>

    <h3>C++ as a better C</h3>

    <p>Welcome to my tutorial on C++. This tutorial assumes that you are already familiar with C
    and builds on concepts from C that you should already know. Be aware that teaching C++ as an
    extension of C is controversial. Some C++ instructors feel it is better to learn C++ on its
    own terms without the student having to unlearn "bad habits" acquired from C. This is a
    reasonable view; C++ provides better ways than C of solving certain problems. It also
    requires a somewhat different way of thinking.</p>

    <p>On the other hand, one of the strengths of C++ is that it is highly compatible with C.
    Many C programs (especially carefully written C programs) will compile as C++ programs with
    no changes. This allows you to start using a C++ compiler on an existing C program and then
    introduce C++ features gradually as necessary. In this way you can take advantage of C++
    without having to rewrite your entire application.</p>

    <p>Also there are situations when C is available, but C++ is not. To work effectively in
    those cases you should understand the difference between C and C++. Learning C first and
    then learning C++ from that background will help keep the two languages distinct in your
    mind. C and C++ <em>are</em> different languages. Despite their close relationship they have
    different goals, different pasts, and probably different futures. It is useful to keep them
    separate in your thinking.</p>

    <p>C++ can be used as a "better C" without delving into the complexities of its more
    advanced features. For example, C++ has a stronger type system than C, meaning that it will
    catch more program errors at compile time than a C compiler could. C++ also has a number of
    convenience features that you can use to make what would otherwise be an ordinary C program
    a little easier to write. Such features include:</p>

    <ul>
      <li>Reference parameters</li>
      <li>Default arguments</li>
      <li>Function and operator overloading</li>
      <li>Dynamic (run-time) initialization of static objects</li>
      <li>Built in memory allocation operators</li>
      <li>User defined constructor and destructor functions</li>
      <li>User defined type conversion operators</li>
      <li>A type-safe IO library</li>
      <li>First class strings and dynamic arrays</li>
    </ul>

    <p>I will discuss all of these features in this tutorial as well as others; don't worry if
    you don't understand what they mean right now.</p>

    <h3>C++ as C++</h3>

    <p>C++ also has several important features that allow it to be used in ways that are awkward
    (at best) for C to emulate. These features allow C++ to be used as an object oriented
    language, as well as also supporting some other important programming paradigms such as
    generic programming. Unlike some object oriented languages you can program in C++ without
    using object oriented techniques. For example, you can write C programs. C++ does not
    require you to use any particularly programming style, but rather lets you apply one of
    several different approaches that best fits the needs of your problem.</p>

    <p>Some of these more advanced features include:</p>

    <ul>
      <li>Support for abstract data types</li>
      <li>Inheritance</li>
      <li>Dynamic polymorphism</li>
      <li>Exceptions</li>
      <li>Generic programming</li>
      <li>Metaprogramming</li>
    </ul>

    <p>I will discuss the first four features above in this tutorial. I will also say a few
    words about generic programming as way of introduction. However, many aspects of these more
    advanced topics are outside the scope of this tutorial. C++ is large and complex. No single
    tutorial, course, or even text book can do justice to the entire language. However, after
    working through this tutorial you should have a good understanding of how C++ supports
    abstract types and object oriented programming. You should also be in a good position to
    read and understand some of the more advanced material on C++.</p>

    <h3>Design goals of C++</h3>

    <p>Like all programming languages, C++ was designed with certain goals in mind. It is useful
    to understand these design goals because doing so allows you to put the features of C++ into
    their proper perspective. Programming language features that seem odd or pointless sometimes
    make sense when you understand the overall philosophy that language is following.</p>

    <ul>
      <li>
        <p><b>C++ should be (almost) compatible with C.</b> The high degree of compatibility
        between C++ and C is no accident. C++ was designed from the beginning with the intention
        that any legal C program should compile as C++ with no change to the meaning of the
        program. Alas, this goal is somewhat inconsistent with C++'s other design goals. As a
        result there are a few features of C that are not allowed in C++ programs. However,
        these features are few and far between; the incompatibilities were only introduced as a
        last resort. It is easy to write C programs that don't use the incompatible features,
        however it is also true that most large C programs that were written without C++ in mind
        will need a bit of editing before being acceptable to a C++ compiler.</p>
      </li>

      <li>
        <p><b>You shouldn't pay for features you don't use.</b> In addition to accepting (most)
        valid C programs, C++ compilers should generate executables for such programs that are
        as fast as a C compiler could produce. In other words, the advanced features in the
        language should not penalize the performance of a program that chooses not to use them.
        As with the first design goal, this goal is not met 100% in C++. There are a couple of
        features that cause a (slight) reduction in performance just by existing in the
        language---even if a program never uses the feature.</p>
      </li>

      <li>
        <p><b>C++ should be suitable for high performance programming and low level
        programming.</b> Even when you do use the advanced features of C++, the execution and
        space performance of your program should still be good. Like C, C++ trades other
        features (like safety) for speed. This makes C++ suitable for use in demanding
        applications that require the highest performance possible. Also, like C, C++ can be
        used for low level hardware control applications. These design goals from C are also
        goals for C++.</p>
      </li>

      <li>
        <p><b>C++ should not require you to use a particular programming style.</b> As I
        mentioned before, it is possible to write object oriented programs in C++, but it is not
        necessary to do so. In cases where the object oriented paradigm is not the most natural
        approach you can simply not use that paradigm. Some programming languages (and some
        programmers) are almost fanatical about the "one true way" of programming. Of course
        everyone has a different point of view about what that one true way might be. C++ is
        intended to be less demanding in this regard. It gives you the tools you need to use a
        variety of programming techniques and lets you decide on how to use those tools.</p>
      </li>
    </ul>

    <h3>Pros and cons of C++</h3>

    <p>I've already discussed some of the advantages of C++: its good performance, its
    compatibility with C, and its flexibility. One advantage I haven't mentioned is its
    expressivity. The advanced features of C++ can be used by themselves or together to
    implement complex and powerful ideas in elegant ways. In some respects this is the most
    exciting aspect of the language. It gives you a way to express the solution to your
    programming problem in a very abstract and general manner.</p>

    <p>However, no overview of C++ would be complete without also talking about the language's
    disadvantages. Probably the biggest such disadvantage is the language's complexity. Because
    it is so complex, C++ is hard to learn and frequently surprises even experts. The complexity
    also has other, indirect negative consequences. C++ compilers tend to be large, slow, and
    buggy (as compared to C compilers) and advanced programming tools are either non-existent or
    expensive (because they are difficult to write). C++ can also be hard to read because it has
    a tricky syntax. Finally, many of C++'s features interact in complicated ways that are hard
    to understand.</p>

    <p>Some of the complexity of C++ is a direct consequence of its advanced features. Any
    language with the expressive power of C++ is going to be complex. However, C++ is more
    complex than necessary. This is largely due to historical reasons. C++ is not a new language
    and it has accumulated baggage over the years. New versions of the language must remain
    compatible with legacy code and so old, bad features end up remaining in the language even
    as new and better ways of doing things are introduced. In addition C++'s dedication to C
    compatibility makes C++ more complicated than would otherwise be the case. C has its own set
    of quirks. Taken alone C's quirks are not a major problem, but after adding on the new
    features of C++ those quirks become magnified into significant issues. Thus C compatibility
    is both an advantage and disadvantage of C++.</p>

    <h2>Summary</h2>

    <ol id="summary-list">
      <li><p>C++ is approximately a super set of C and thus most C programs will compile without
      changes as C++ programs.</p></li>

      <li><p>C++ provides many new features relative to C and it enables many additional
      programming techniques.</p></li>

      <li><p>C++ was intended to retain the efficiency of C in part by not requiring you to pay
      a performance penalty for advanced features you don't use. C++ was intended to support
      very large programming projects.</p></li>

      <li><p>C++ is very powerful and expressive. It allows the programmer to use many advanced
      programming techniques. However, C++ is also very complex and hard to master. It contains
      a number of warts and odd (mis)features related to its C compatibility and to its
      age.</p></li>
    </ol>

    <address>
      &copy; Copyright 2016 by Peter C. Chapin.<br />
      Last Revised: <b>January 12, 2016</b>
</address>

  </body>
</html>
